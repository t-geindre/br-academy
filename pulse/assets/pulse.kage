package game
//kage:unit pixels

var Time float
var Pulse float

func cosPalette(t float, a, b, c, d vec3) vec3 {
	return a + b * cos(6.2831853 * (c*t + d))
}

func palNeon(t float) vec3 {
	return cosPalette(t, vec3(0.5), vec3(0.5), vec3(1), vec3(0.00, 0.33, 0.67))
}

func sinRange(t float, a, b float) float {
    return a + (b - a) * (sin(t) + 1) / 2
}

func radialWarp(uv vec2, k float, ar float) vec2 {
    p := uv - vec2(0.5)
    p.x *= ar

    r := length(p)
    s := sin(min(1.0, r) * 1.5707963) // ~PI/2

    p *= (1.0 + k * s)
    p.x /= ar

    return clamp(p + vec2(0.5), vec2(0), vec2(1))
}

func Fragment(pos vec4, local vec2) vec4 {
    // Pre calculate sins
    sin10 := sin(Time/10)
    sin8 := sin(Time/8)

    // Background
    background := vec4(0)

    // Normalize [0, 1]
    canvas := imageSrc0Size()
    ar := canvas.x / canvas.y
    uv := local / canvas

    // 3D Distortion
    // uv *= sin(uv.x)
    uv = radialWarp(uv, sinRange(Time+Pulse/2, -.7,-.5), ar)

    // Scroll
    uv.x += sin(Time/16)
    uv.y += cos(Time/24)

    // Pulser ratio correction + center
    d := uv - vec2(0.5, 0.5)
    d.x *= ar

    // Repeat pattern + zoom sin
    d = fract(d * sinRange(Time/2, 4, 10)) - vec2(0.5, 0.5)

    // Fract dist (repeat circles)
    dist := length(d)
    dist = fract(dist * 6*sinRange(Time, .9, 1))

    // Circle color
    circColor := vec4(palNeon(
        // uv.x / 10 * sin8 + d.x / 5 * sin10 + d.y / 5 * sin10 + uv.x/10 * sin8,
        (uv.x / 10 + d.x / 5) * sin10 * 2 + (uv.y /10 + d.y / 5) * sin8 * 2,
    ), 1)

    // Radius variation
    p := Pulse * .4 // Pulse variation
    s := sinRange(Time, 0, 1)*.5 // Sinusoidal variation
    r := .1 + p + s // Final Radius

    // Circle
    thick, aa := .1, .01
    ring := smoothstep(r - thick - aa, r - thick + aa, dist) - smoothstep(r + thick - aa, r + thick + aa, dist)

    return mix(background, circColor, ring)
}