package shaders
//kage:unit pixels

// Background
var BaseColor vec4
var GlowLeft vec4
var GlowRight vec4

var Intensity float
var Spread float

// Animation
var Time float

// Game zone
var Margin float
var CornerRadius float
var BorderThickness float
var BorderColor vec4

// Animation noise
func noise(p vec2) float {
    return 0.8 + 0.2 * sin((p.x + p.y) * 0.01 + Time * 0.01)
}

// Rounded rect
func roundRectDist(p, size vec2, radius float) float {
    q := abs(p - size * 0.5) - size * 0.5 + vec2(radius, radius)
    return length(max(q, vec2(0))) - radius
}

func Fragment(pos vec4, uv vec2, col vec4) vec4 {
    x := pos.x
    y := pos.y
    canvas := imageDstSize()

    boardPos := vec2(Margin, Margin)
    boardSize := canvas - vec2(Margin * 2.0, Margin * 2.0)
    localPos := vec2(x, y) - boardPos

    SpreadL := Spread * (0.7 + 0.2 * sin(Time/120))
    SpreadR := Spread * (0.7 + 0.2 * sin(Time/160))

    distLeft  := length(vec2(x, y)) / SpreadL
    distRight := length(vec2(canvas.x - x, y)) / SpreadR

    glowL := GlowLeft * max(0.0, (1.0 - distLeft)) * (0.8 + 0.2 * noise(vec2(x,y)))
    glowR := GlowRight * max(0.0, (1.0 - distRight)) * (0.8 + 0.2 * noise(vec2(x + 10.0,y + 10.0)))

    background := BaseColor + Intensity * (glowL + glowR)


    // Distance au bord du rectangle arrondi
    d := roundRectDist(localPos, boardSize, CornerRadius)

    if d < 0.0 {
        return background - vec4(.1,.1,.1,0)
    }

    if d < BorderThickness {
        return BorderColor
    }

    return background
}
